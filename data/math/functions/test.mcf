#math:test

构造方式:function
	·依次执行与嵌套执行
	·函数层级与s命名法

构造方式:execute
	实时解析与预解析
	execute嵌套问题

·分支
	·简单分支
		前后无关性问题
		嵌套的化解:顺序化分支
		条件的与或非运算
		条件频率与开销
	·记分板树
		长度与分支因子x
		非整数类型的记分板树

·常用调试技巧
	·测试方法
		·黑箱测试
		·可视化测试
	·搜索异常
		·直觉与经验
		·执果索因
		·断点信息
		·日志法

定时炸弹的数据模板：
{time:0,power:0,pos:[0.0d,0.0d,0.0d],rot:[0.0f,0.0f]}

#timebomb:_new
#执行者是世界实体
tp @s ~ ~ ~ ~ ~
execute unless data storage math:io input.pos run data modify storage math:io input.pos set from entity @s Pos
execute unless data storage math:io input.rot run data modify storage math:io input.rot set from entity @s Rotation
tag @e remove result
summon marker 0 11 0 {Tags:["result"]}
execute as @e[tag=result,limit=1] run function timebomb:set

#timebomb:set
execute store result score @s id run scoreboard players add #id int 1
data modify entity @s Pos set from storage math:io input.pos
data modify entity @s Rotation set from storage math:io input.rot
data modify entity @s data.power set from storage math:io input.power
execute store result score temp int run data get storage math:io input.time
data modify storage math:io input set value {cmd:"execute as @e[tag=as_entity,limit=1] at @s run function timebomb:explode"}
execute store result storage math:io input.time int 1 run scoreboard players operation temp int += gametime int
function timer:_setas
function timer:_new

#timebomb:explode
summon creeper 0 11 0 {Tags:["tmp"],Fuse:0}
data modify entity @e[tag=tmp,limit=1] ExplosionRadius set from entity @s data.power
tp @e[tag=tmp,limit=1] ~ ~ ~
kill @s

#假设有两个实体
scoreboard players set test int 0
execute as @e if score test int matches 0 store result score test if if score test int matches 0

#shoot
execute anchored eyes run summon fireball ^ ^ ^0.5 {Tags:["tmp"]}
execute positioned 0.0 0.0 0.0 as @e[tag=tmp,limit=1] run function #set_velocity

#set_velocity
tp @e[tag=math_marker,limit=1] ^ ^ ^1.5
data modify entity @s power set from entity @e[tag=math_marker,limit=1] Pos
tag @s remove tmp

#state_trans
data modify storage math:io input set value {cmd:"execute as @e[tag=dcmd_as,limit=1] store result score @s state run data get storage math:io run_space.state",time:10}
data modify storage math:io input.uuid set from entity @s UUID

function math:_rand
scoreboard players operation random int %= 2 int
execute if score @s state matches 1 run scoreboard players set random int 1
execute if score @s state matches 2 run scoreboard players set random int -1
execute store result storage math:io input.run_space.state int 1 run scoreboard players add random int 1

function timer:_new

func _topos{
	#传入世界实体为执行者，输入编号，输出到世界实体的坐标
	scoreboard players operation stempy int = inp int
	scoreboard players operation stempz int = inp int

	scoreboard players operation stempy int /= area_xz int
	execute store result entity @s Pos[1] double 1 run scoreboard players operation stempy int += start_y int
	scoreboard players operation stempz int %= area_xz int

	scoreboard players operation stempx int = stempz int
	scoreboard players operation stempz int /= len_x int
	execute store result entity @s Pos[2] double 1 run scoreboard players operation stempz int += start_z int

	scoreboard players operation stempx int %= len_x int
	execute store result entity @s Pos[0] double 1 run scoreboard players operation stempx int += start_x int

	#对齐到方块中心
	execute at @s run tp @s ~0.5 ~0.5 ~0.5
}

func _posto{
	#传入世界实体为执行者，输入执行坐标，输出编号
	execute align xyz run tp @s ~0.5 ~0.5 ~0.5
	execute store result score res int run data get entity @s Pos[0]
	execute store result score stempy int run data get entity @s Pos[1]
	execute store result score stempz int run data get entity @s Pos[2]
	scoreboard players operation res int -= start_x int
	scoreboard players operation stempy int -= start_y int
	scoreboard players operation stempz int -= start_z int

	scoreboard players operation stempy int *= area_xz int
	scoreboard players operation stempz int *= len_x int
	scoreboard players operation res int += stempy int
	scoreboard players operation res int += stempz int
}

type{
	string s;
	int key,cnt;
	list ptrs,same;
	bool tag;
} node;

list top;

#全部元素节点输入到top列表，初始cnt为0，ptrs和same为空，tag为true
input(top);

while(true)
{
	int i=0,n=len(top);
	if(n<1) break;
	if(n==1)
	{
		int j=0,l=len(top[0].ptrs);
		while(j<l)
		{
			*(top[0].ptrs[0]).cnt--;
			if(*(top[0].ptrs[0]).cnt==0) top<<*(top[0].ptrs[0]),*(top[0].ptrs[0]).tag=true;
			top[0].ptrs++,j++;
		}
		output(top[0]),top++,top>>,n=len(top);
	}
	while(i<n)
	{
		if(top[1].key>top[0].key) top[0].ptrs<<&top[1],top[1].tag=false,top[0].cnt++;
		else if(top[1].key<top[0].key) top[1].ptrs<<&top[0],top[0].tag=false,top[1].cnt++;
		else top[0].same<<&top[1],top[0].tag=false;
		top++,i++;
	}
	i=0;
	while(i<n)
	{
		top++,i++;
		if(!top[-1].tag) top>>;
	}
}

#loop
data modify storage math:io list prepend from storage math:io list[-1]
data remove storage math:io list[-1]
execute if ... run function #loop
data modify storage math:io list append from storage math:io list[0]
data remove storage math:io list[0]

execute as @e[tag=math_marker,limit=1] run function math:qrot/facing/_2toxyzw
execute as @e[tag=math_marker,limit=1] run function math:qrot/pose/_xyzwto
scoreboard players set u int 0
scoreboard players set v int 0
scoreboard players set w int 10000
function math:qrot/axis/_uvwto

scoreboard players set qror_alpha int 225000
execute as @e[tag=math_marker,limit=1] run function math:qrot/_xyzw
execute as @e[tag=math_marker,limit=1] run function math:qrot/pose/_xyzwto
scoreboard players set u int 0
scoreboard players set v int 10000
scoreboard players set w int 0
function math:qrot/axis/_uvwto

scoreboard players set qror_alpha int 225000
execute as @e[tag=math_marker,limit=1] run function math:qrot/_stoxyzw